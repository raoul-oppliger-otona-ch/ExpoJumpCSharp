"use strict";

// Simple-minded, absolutely unoptimized Reed-Solomon codec. Mainly based on this paper:
// https://downloads.bbc.co.uk/rd/pubs/whp/whp-pdf-files/WHP031.pdf
//
// Also tested against the examples in this QR code error correction tutorial:
// http://www.thonky.com/qr-code-tutorial/error-correction-coding

// A GF(16) finite field with the generator polynomial x^4 + x + 1. Not actually used in QR codes
// but it sure was easier to debug the codec with this than with GF(256).
class GF16 {
  constructor(v) {
    this.v = v;
  }
  
  add(b) {
    return GF16.values[GF16.addTable[this.v][b.v]];
  }

  mul(b) {
    return GF16.values[GF16.mulTable[this.v][b.v]];
  }
  
  inv() {
    return GF16.values[GF16.invTable[this.v]];
  }
  
  log() {
    assert(this.v !== 0, "Log of GF16(0)");
    return GF16.log[this.v];
  }
  
  toString() {
    let logSuffix = this.v === 0 ? "" : " / a^" + this.log();
    return "H(" + this.v + ")" + logSuffix;
  }
  
  static get(i) {
    return GF16.values[i];
  }
  
  static nul() {
    return GF16.values[0];
  }
  
  static one() {
    return GF16.values[1];
  }
  
  static size() {
    return 16;
  }
  
  static alpha(i) {
    return GF16.exp[i % 15];
  }
  
  static header(obj) {
    if (!(obj instanceof GF16)) {
      return null;
    }
    
    let logSuffix = obj.v === 0 ? "" : " / a^" + obj.log();
    let result = "H(" + obj.v + ")" + logSuffix;
    return ["div",  result];
  }
  
  static hasBody(obj) {
    return false;
  }
  
  static init() {
    GF16.addTable = [];
    for (let a = 0; a < 16; a++) {
      let row = [];
      for (let b = 0; b < 16; b++) {
        row.push(a^b);
      }
      GF16.addTable.push(row);
    }
    
    // I could have computed this in the way GF(256) was done, but I'm tired and grumpy and thus
    // will just copy the multiplication table from the BBC paper.
    GF16.mulTable = [
      [0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
      [0,  1,  2 , 3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15],
      [0,  2,  4,  6,  8, 10, 12, 14,  3,  1,  7,  5, 11,  9, 15, 13],
      [0,  3,  6,  5, 12, 15, 10,  9, 11,  8, 13, 14,  7,  4,  1,  2],
      [0,  4,  8, 12,  3,  7, 11, 15,  6,  2, 14, 10,  5,  1, 13,  9],
      [0,  5, 10, 15,  7,  2, 13,  8, 14, 11,  4,  1,  9, 12,  3,  6],
      [0,  6, 12, 10, 11, 13,  7,  1,  5,  3,  9, 15, 14,  8,  2,  4],
      [0,  7, 14,  9, 15,  8,  1,  6, 13, 10,  3,  4,  2,  5, 12, 11],
      [0,  8,  3, 11,  6, 14,  5, 13, 12,  4, 15,  7, 10,  2,  9,  1],
      [0,  9,  1,  8,  2, 11,  3, 10,  4, 13,  5, 12,  6, 15,  7, 14],
      [0, 10,  7, 13, 14,  4,  9,  3, 15,  5,  8,  2,  1, 11,  6, 12],
      [0, 11,  5, 14, 10,  1, 15,  4,  7, 12,  2,  9, 13,  6,  8,  3],
      [0, 12, 11,  7,  5,  9, 14,  2, 10,  6,  1, 13, 15,  3,  4,  8],
      [0, 13,  9,  4,  1, 12,  8,  5,  2, 15, 11,  6,  3, 14, 10,  7],
      [0, 14, 15,  1, 13,  3,  2, 12,  9,  7,  6,  8,  4, 10, 11,  5],
      [0, 15, 13,  2,  9,  6,  4, 11,  1, 14, 12,  3,  8,  7,  5, 10]];
      
    // Generated by the sophisticated method of eyeballing the above table.
    GF16.invTable = [0, 1, 9, 14, 13, 11, 7, 6, 15, 2, 12, 5, 10, 4, 3, 8];
    
    // Some consistency checks in case manual copy-paste did not go perfectly.
    for (let i = 0; i < 16; i++) {
      let rs = 0, cs = 0;
      for (let j = 0; j < 16; j++) {
        rs += GF16.mulTable[i][j];
        cs += GF16.mulTable[j][i];
        assert(GF16.mulTable[i][j] === GF16.mulTable[j][i]);
      }
      
      assert(i === 0 || rs === (15*16/2));
      assert(i === 0 || cs === (15*16/2));
      assert(i === 0 || GF16.mulTable[i][GF16.invTable[i]] === 1);
      assert(i === 0 || GF16.mulTable[GF16.invTable[i]][i] === 1);
    }
    
    GF16.values = [];
    for (let i = 0; i < 16; i++) {
      GF16.values.push(new GF16(i));
    }
    
    GF16.exp = new Array(16);
    GF16.log = new Array(16);
    
    let current = 1;
    for (let i = 0; i < 16; i++) {
      GF16.exp[i] = GF16.values[current];
      GF16.log[current] = i;
      current = GF16.mulTable[current][2];
    }
    
    GF16.log[1] = 0;
    window.devtoolsFormatters.push(GF16);
  }
}

// The GF(256) finite field used in QR codes. That is, addition is XOR, multiplication is
// polynomial multiplication modulo whatever polynomial decimal 285 represents.
class GF256 {
  constructor(v) {
    this.v = v;
  }
  
  add(b) {
    GF256.assertIs(b);
    let result = this.v ^ b.v;
    return GF256.values[result];
  }
  
  mul(b) {
    GF256.assertIs(b);
    if (this.v === 0 || b.v === 0) {
      return GF256.values[0];
    }
    let loga = GF256.log[this.v];
    let logb = GF256.log[b.v];
    return GF256.exp[(loga + logb) % 255];
  }
  
  log() {
    if (this.v === 0) {
      throw "log of 0";
    }
    
    return GF256.log[this.v];
  }
  
  exp() {
    return GF256.exp[this.v];
  }
  
  inv() {
    return GF256.exp[255 - GF256.log[this.v]];
  }

  pow(p) {
    GF256.assertNumber(p);
    let result = GF256.values[1];
    let current = this;
    while (p !== 0) {
      if (p & 1) {
        result = result.mul(current);
      }
      
      p >>= 1;
      current = current.mul(current);
    }
    
    return result;
  }
  
  toString() {
    return "G(" + this.v + ")";
  }
  
  static get(i) {
    return GF256.values[i];
  }
  
  static alpha(i) {
    return GF256.exp[i % 255];
  }
  
  static nul() {
    return GF256.values[0];
  }
  
  static one() {
    return GF256.values[1];
  }
  
  static size() {
    return 256;
  }
  
  static assertIs(a) {
    assert(a instanceof GF256, "Not a GF element");
  }
  
  static assertNot(a) {
    assert(!(a instanceof GF256), "Is a GF element");
  }
  
  static assertNumber(a) {
    assert(typeof(a) === "number", "Is not a number");
  }
  
  static init() {
    GF256.values = [];
    for (let i = 0; i < 256; i++) {
      GF256.values.push(new GF256(i));
    }
    
    GF256.exp = new Array(256);
    GF256.log = new Array(256);
    let i = 0;
    let current = 1;
    for (let i = 0; i < 256; i++) {
      GF256.exp[i] = GF256.values[current];
      GF256.log[current] = i;
      current = current * 2;
      if (current > 255) {
        current ^= 285;
      }
    }
    
    GF256.log[1] = 0;
    
    window.devtoolsFormatters = window.devtoolsFormatters || [];
    window.devtoolsFormatters.push(GF256);
    window.devtoolsFormatters.push(Poly);
  }
  
  static header(obj) {
    if (!(obj instanceof GF256)) {
      return null;
    }
    
    let result = "G(" + obj.v + ")";
    if (obj.v !== 0) {
      result += " / a^" + obj.log();
    }
    return ["div",  result];
  }
  
  static hasBody(obj) {
    return false;
  }
}


// A polynomial over a finite field. Representation is a simple array with the first element the
// coefficient for x^0, the second for x^1 and so on.
class Poly {
  constructor(field, terms) {
    this.field = field;
    let i = terms.length - 1;
    while (terms[i] === field.nul() && i >= 0) {
      i--;
    }
    
    this.terms = terms.slice(0, i+1);
  }
  
  get(power) {
    return power < this.terms.length ? this.terms[power] : this.field.nul();
  }
  
  deg() {
    return this.terms.length - 1;
  }
  
  eq(b) {
    if (this.terms.length !== b.terms.length) {
      return false;
    }
    
    for (let i = 0; i < this.terms.length; i++) {
      if (this.terms[i] !== b.terms[i]) {
        return false;
      }
    }
    
    return true;
  }
  
  add(b) {
    assert(this.field === b.field);
    let result = new Array(Math.max(this.terms.length, b.terms.length));
    for (let i = 0; i < result.length; i++) {
      result[i] = this.get(i).add(b.get(i));
    }
    
    return new Poly(this.field, result);
  }
  
  mul(b) {
    assert(this.field === b.field);
    let rows = [];
    let prefix = [];
    for (let bt of b.terms) {
      let row = prefix.slice();
      for (let v of this.terms) {
        row.push(v.mul(bt));
      }
      
      rows.push(new Poly(this.field, row));
      prefix.push(this.field.nul());
    }
    
    let result = new Poly(this.field, []);
    for (let row of rows) {
      result = result.add(row);
    }
    
    return result;
  }

  scale(f) {
    assert(f instanceof this.field);
    return new Poly(this.field, this.terms.map( c => c.mul(f)));
  }
  
  div(b) {
    assert(this.field === b.field);
    assert(this.terms.length >= b.terms.length, "Polynomial dividend must rank higher than divisor");
    let resultTerms = [];
    let remainder = this;
    
    while (remainder.terms.length >= b.terms.length) {
      let pow = remainder.terms.length - b.terms.length;
      let factor = b.terms[b.terms.length - 1].inv().mul(remainder.terms[remainder.terms.length - 1]);
      while (resultTerms.length !== this.terms.length - b.terms.length - pow) {
        resultTerms.push(this.field.nul());
      }
      let row = [];
      for (let i = 0; i < pow; i++) {
        row.push(this.field.nul());
      }
      
      for (let bt of b.terms) {
        row.push(bt.mul(factor));
      }
      
      let oldRemainder = remainder;
      remainder = remainder.add(new Poly(this.field, row));
      assert(remainder.terms.length < oldRemainder.terms.length, "Polynomial division does not progress");
      resultTerms.push(factor);
    }
    
    while (resultTerms.length <= this.terms.length - b.terms.length) {
      resultTerms.push(this.field.nul());
    }
    return [new Poly(this.field, resultTerms.reverse()), remainder];
  }
  
  eval(v) {
    assert(v instanceof this.field);
    
    // Horner's method
    let result = this.field.nul();
    for (let term of this.terms.slice().reverse()) {
      result = result.mul(v).add(term);
    }
    
    return result;
  }
  
  toString() {
    let coefficients = [];
    for (let i = 0; i < this.terms.length; i++) {
      if (this.terms[i] !== this.field.nul()) {
        let factor = i === 0 ? "" : "*x^" + i;
        coefficients.push(this.terms[i].toString() + factor);
      }
    }
    
    return coefficients.reverse().join(" + ");
  }
  
  static create(field, terms) {
    return new Poly(field, terms.map(t => field.get(t)));
  }
  
  // Extended Euclid's algorithm to find s, t and r such that r=GCD(a,b) and
  // a*s + b*t = r
  // Shamelessly cribbed from Wikipedia. Stops when degree of remainder is less than deg.
  static euclid(field, a, b, deg) {
    let s = new Poly(field, []);
    let old_s = new Poly(field, [field.one()]);
    let t = new Poly(field, [field.one()]);
    let old_t = new Poly(field, []);
    let r = b;
    let old_r = a;
    
    while (r.deg() >= deg) {
      // console.log("r = " + r.toString());
      // console.log("a = " + a.toString());
      // console.log("b = " + b.toString());
      let [quot, rem] = old_r.div(r);
      // console.log("quotient: " + quot.toString());
      // console.log("remainder: " + rem.toString());
      [old_r, r] = [r, rem];
      [old_s, s] = [s, old_s.add(quot.mul(s))];
      [old_t, t] = [t, old_t.add(quot.mul(t))];
      
      // console.log("s = " + s.toString());
      // console.log("t = " + t.toString());
    }
    
    return [s, t, r];
  }
  
  static header(obj) {
    if (!(obj instanceof Poly)) {
      return null;
    }
    
    let result = "Poly(" + obj.toString() + ")";
    return ["span", {}, result];
  }
  
  static hasBody(obj) {
    return true;
  }
  
  static body(obj) {
    return ["div", {style: "display: block"}].concat(obj.terms.map((e, i) => ["li", {}, "x^" + i + ": ", ["object", {object: e}]]));
  }
}

class RSCodec {
  // Returns the generator polynomial for K error correction symbols with the first factor being
  // alpha^b. b should usually be zero.
  static generatorPolynomial(field, k, b) {
      let result = Poly.create(field, [1]);
      let atob = field.alpha(b);
      for (let i = b; i < b + k; i++) {
        let factor = new Poly(field, [atob, field.one()]);
        result = result.mul(factor);
        atob = atob.mul(field.alpha(1));
      }
      
      return result;
  }
  
  // Encode a given message with a given generator polynomial.
  static encode(message, generator) {
    assert(message.field === generator.field);
    let lengthened = new Poly(message.field,
        new Array(generator.deg()).fill(message.field.nul()).concat(message.terms));
    // console.log("Lengthened:");
    // console.log(lengthened);
    let [, remainder] = lengthened.div(generator);
    // console.log("Remainder:");
    // console.log(remainder);
    return lengthened.add(remainder);
  }
  
  static runEuclideanAlgorithm(field, syndrome, t) {
    let t2terms = new Array(t*2).fill(field.nul());
    t2terms.push(field.one());
    let t2 = new Poly(field, t2terms);
    // console.log("S(x) = " + syndrome);
    // console.log("t2(x) = " + t2);
    let [f, lambda, sigma] = Poly.euclid(field, t2, syndrome, t);
    // console.log("Lambda(x) = " + lambda.toString());
    // console.log("Sigma(x) = " + sigma.toString());
    // console.log("F(x) = " + sigma.toString());
    let factor = lambda.get(0).inv();
    lambda = lambda.scale(factor);
    f = f.scale(factor);
    sigma = sigma.scale(factor);
    // console.log("corrected Lambda(x) = " + lambda.toString());
    // console.log("corrected Sigma(x) = " + sigma.toString());
    // console.log("corrected F(x) = " + f.toString());
    let cross = syndrome.mul(lambda).add(t2.mul(f));
    // console.log("cross-check (should be Sigma): " + cross);
    
    return [lambda, sigma];
  }
  
  // Would be a Chien search... if we actually did the optimization suggested by him. As it is,
  // it's just searching for roots in a particular order.
  static chienSearch(field, lambda, n, k) {
    let result = [];
    for (let i = n + k - 1; i >= 0; i--) {
      let v = field.alpha(i).inv();
      let evaluated = lambda.eval(v);
      // console.log("Chien search: i=-" + i + ", v="  + v + ", evaluated=" + evaluated);
      if (evaluated === field.nul()) {
        result.push(i);
      }
    }
    
    // console.log("Chien search error locations: " + result);
    if (result.length > Math.floor(k / 2) || result.length === 0) {
      // throw "Uncorrectable errors found";
    }
    console.log("Errors: " + result.length);
    return result;
  }
  
  static computeErrorMagnitude(field, lambdaDerivative, sigma, location, b) {
    // I *think* this is the same for both the BBC paper and QR codes
    assert(b === 0, "b !== 0 not supported");
    let xj = field.alpha(location);
    let dividend = sigma.eval(xj.inv());
    let divisor = lambdaDerivative.eval(xj.inv());
    return xj.mul(dividend).mul(divisor.inv());
  }
  
  static forneyDerivative(lambda) {
    let terms = lambda.terms.slice();
    terms.shift();  // Remove the constant term and divide through by x
    // Set all even-powered terms to zero because apparently that's okay. It's magic. But then
    // again, a lot of things here are.
    for (let i = 1; i < terms.length; i += 2) {
      terms[i] = lambda.field.nul();
    }
    
    return new Poly(lambda.field, terms);
  }
  
  // Decodes a message with N data symbols and K error correction symbols.
  static decode(received, n, k) {
    // Hopefully; I don't know if this is the right stopping condition for the Euclidean algorithm
    let t = Math.floor(k/2);
    let syndrome = RSCodec.computeSyndrome(received, 0, k);
    if (syndrome.terms.length === 0) {
      // No errors. Carry on.
      return new Poly(received.field, received.terms.slice(k));
    }
    // console.log("Syndrome: " + syndrome);
    
    let [lambda, sigma] = RSCodec.runEuclideanAlgorithm(received.field, syndrome, t);
    
    let errorLocations = RSCodec.chienSearch(syndrome.field, lambda, n, k);
    
    let lambdaDerivative = RSCodec.forneyDerivative(lambda);
    // console.log("Forney derivative: " + lambdaDerivative);
    
    let errorTerms = new Array(n+k).fill(received.field.nul());
    for (let errorLocation of errorLocations) {
      let errorMagnitude = RSCodec.computeErrorMagnitude(
          syndrome.field, lambdaDerivative, sigma, errorLocation, 0);
      // console.log("Error magnitude for location " + errorLocation + ": " + errorMagnitude);
      errorTerms[errorLocation] = errorMagnitude;
    }
    
    let error = new Poly(received.field, errorTerms);
    // console.log("Error polynomial: " + error);
    let reconstructed = received.add(error);
    // console.log("Reconstructed polynomial: ");
    // console.log(reconstructed);
    
    let result = new Poly(reconstructed.field, reconstructed.terms.slice(k));
    // console.log("Message:");
    // console.log(result);
    return result;
  }
  
  static computeSyndrome(received, b, k) {
    let terms = [];
    for (let i = 0; i < k; i++) {
      let v = received.field.alpha(i + b);
      terms.push(received.eval(v));
    }
    
    return new Poly(received.field, terms);
  }
}

GF256.init();
GF16.init();